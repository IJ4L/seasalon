// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: services.sql

package db

import (
	"context"
)

const deleteServices = `-- name: DeleteServices :exec
DELETE FROM services
WHERE ID = $1
`

func (q *Queries) DeleteServices(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteServices, id)
	return err
}

const getService = `-- name: GetService :one
SELECT id, idbranch, name, type, detail, pricing, duration, createdat, updatedat FROM services
WHERE ID = $1
`

func (q *Queries) GetService(ctx context.Context, id int32) (Service, error) {
	row := q.db.QueryRowContext(ctx, getService, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Idbranch,
		&i.Name,
		&i.Type,
		&i.Detail,
		&i.Pricing,
		&i.Duration,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getServices = `-- name: GetServices :many
SELECT id, idbranch, name, type, detail, pricing, duration, createdat, updatedat FROM services
`

func (q *Queries) GetServices(ctx context.Context) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getServices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Idbranch,
			&i.Name,
			&i.Type,
			&i.Detail,
			&i.Pricing,
			&i.Duration,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServicesByBranch = `-- name: GetServicesByBranch :many
SELECT id, idbranch, name, type, detail, pricing, duration, createdat, updatedat FROM services
WHERE Type = $1
`

func (q *Queries) GetServicesByBranch(ctx context.Context, type_ string) ([]Service, error) {
	rows, err := q.db.QueryContext(ctx, getServicesByBranch, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Idbranch,
			&i.Name,
			&i.Type,
			&i.Detail,
			&i.Pricing,
			&i.Duration,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertServices = `-- name: InsertServices :one
INSERT INTO services (IDBranch, Name, Type, Detail, Pricing, Duration)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, idbranch, name, type, detail, pricing, duration, createdat, updatedat
`

type InsertServicesParams struct {
	Idbranch int32  `json:"idbranch"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	Detail   string `json:"detail"`
	Pricing  string `json:"pricing"`
	Duration int32  `json:"duration"`
}

func (q *Queries) InsertServices(ctx context.Context, arg InsertServicesParams) (Service, error) {
	row := q.db.QueryRowContext(ctx, insertServices,
		arg.Idbranch,
		arg.Name,
		arg.Type,
		arg.Detail,
		arg.Pricing,
		arg.Duration,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Idbranch,
		&i.Name,
		&i.Type,
		&i.Detail,
		&i.Pricing,
		&i.Duration,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const updateServices = `-- name: UpdateServices :exec
UPDATE services
SET Name = $2, Type = $3, Detail = $4, Pricing = $5, Duration = $6, UpdatedAt = CURRENT_TIMESTAMP
WHERE ID = $1
`

type UpdateServicesParams struct {
	ID       int32  `json:"id"`
	Name     string `json:"name"`
	Type     string `json:"type"`
	Detail   string `json:"detail"`
	Pricing  string `json:"pricing"`
	Duration int32  `json:"duration"`
}

func (q *Queries) UpdateServices(ctx context.Context, arg UpdateServicesParams) error {
	_, err := q.db.ExecContext(ctx, updateServices,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Detail,
		arg.Pricing,
		arg.Duration,
	)
	return err
}
